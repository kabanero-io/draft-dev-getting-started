---
permalink: /guides/dev-getting-started/
---
:projectid: dev-getting-started
:page-layout: guide
:page-duration: 75 minutes
:page-description: Workshop content for developers and solution architects getting started with Kabanero
:page-tags: ['Appsody', 'Nodejs', 'Express', 'Collection']
:page-title: Getting Started With Kabanero Development
:linkattrs:

:kabanero-collection: v0.2.0-beta1

= Getting Started With Kabanero Development

== What is Kabanero

Kabanero is an open source project focused on bringing together key
foundational open source technologies into a framework for developing
and deploying modern cloud-native applications. The Kabanero developer
experience leverages the Appsody and Eclipse Codewind open source
projects enabling developers to use project 'templates' to rapidly
create new cloud-native applications, develop and build them in a
curated container 'stack' environment and deploy them to
Knative/Kubernetes all without the need for container or Kubernetes
skills.

== What you will learn

This tutorial will give you an introduction to the Kabanero developer
experience. You’ll create and deploy a Node.js cloud-native application, 
however, Kabanero provides a number of stacks,
including Java and Spring Boot, and is extensible so others can easily
be added. For more information, see https://appsody.dev/[Appsody.dev].

At the end of this tutorial, you should have a good understanding of the
Kabanero developer experience through the use of Appsody and Eclipse
Codewind. You’ll know how to create a new application, develop and
deploy it to Knative, and have an appreciation for how Kabanero does all
the heavy-lifting, helping you focus on the task of writing the code.


== Pre-requisites

You need to install the following pre-requisites to
complete this tutorial:

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
- https://code.visualstudio.com/[Visual Studio Code]
- https://docs.docker.com/docker-for-mac/[Docker Desktop]

--

[.tab_content.windows_section]
--
- Windows 10 Professional or Windows 10 Enterprise.
- https://code.visualstudio.com/[Visual Studio Code]
- https://docs.docker.com/docker-for-windows/[Docker Desktop]
- Follow the instructions in the
link:docker-windows-aad[Special notes about Docker Desktop on Windows
10] to ensure your Docker installation can successfully write content to
volumes mounted into containers.
- https://www.cygwin.com/[Cygwin].
- Ensure your Cygwin home directory *matches your Windows home directory*, as
described in
https://ryanharrison.co.uk/2015/12/01/cygwin-change-home-directory.html[this
blog entry]. 
- The workshop content *has not* been validated against the
https://docs.microsoft.com/en-us/windows/wsl[Windows Subsystem for Linux
(WSL)].
--

=== Enable Kubernetes 

Docker Desktop contains a standalone Kubernetes cluster for development purposes.
You will need to enable Kubernetes as this is disabled by default in Docker Desktop. 

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
Open the "Preferences" dialog, switch to the "Kubernetes" tab, and select the "Enable Kubernetes" 
option, as described in the 
https://docs.docker.com/docker-for-mac/#kubernetes[Docker Destop for Mac] page.

[.tab_content.windows_section]
Open the "Settings" dialog, switch to the "Kubernetes" tab, and select the "Enable Kubernetes" 
option, as described in the 
https://docs.docker.com/docker-for-windows/#kubernetes[Docker Destop for Windows] page.


=== Installing the Codewind Extension for Visual Studio Code

https://www.eclipse.org/codewind/[Eclipse Codewind] provides a set of extensions to IDEs for doing
cloud-native application development. They enable a full developer/debug
cycle with an incremental build where all the code is built and run
inside a container. This means that the likelihood of issues due to
different development, build and production environments is vastly
reduced.

Although Codewind is an Eclipse project, it’s not limited to the Eclipse
IDE and in this tutorial, you will use Codewind inside Visual Studio
Code.

Codewind requires Docker, so before you begin, ensure your Docker
install is complete and running.

To install the "Codewind Extension" for "Visual Studio Code", you have
two options.

. Install using the *Install* button on
https://marketplace.visualstudio.com/items?itemName=IBM.codewind[this
page].
. Manually launch Visual Studio Code, navigate to the *Extensions* view,
search for *Codewind*, and install the extension from here.

=== Installing the Appsody CLI

Depending on your operating system, the installation process for the
*Appsody CLI* will differ. To correctly install *Appsody* for your
operating system, view the following
https://appsody.dev/docs/getting-started/installation[link].

Verify that the CLI tool is installed correctly by executing the
following into your terminal:

[source, role='command']
```
appsody version
```

=== Sharing the Appsody Configuration between the CLI and Visual Studio Code - Optional

While this is optional, it is recommended. Rather than having *Appsody
CLI* projects stored separately to those you may create in an editor
such as *Visual Studio Code* or *Eclipse*, updating the *Appsody*
configuration file will enable you to work on your projects across both
the CLI and editor.

To share the Appsody configuration, follow the instructions at
https://github.com/eclipse/codewind-appsody-extension#optional-using-the-same-appsody-configuration-between-local-cli-and-codewind[this
repository].

=== Pre-requisite checks and caching of large images

This step will ensure your environment has all the prerequisites
installed and running.

In addition to checking prerequisites, this step will also cache large
images into your local system. The cached content will save you valuable
time at the beginning of the workshop.

(Windows users should execute it from a Cygwin shell) :

[source, role='command']
```
curl -sL https://github.com/gcharters/kabanero-dev-getting-started/releases/download/0.0.4/workshop-setup.sh | bash -s -- -p -l nodejs
```

== Developing Cloud-native applications - Appsody

=== Getting to know Appsody

We are going to start by trying out the developer experience Appsody
provides and then we’ll move on to use Eclipse Codewind.

Let’s take a look at what Appsody provides in terms of capabilities. In
a command prompt, type:

[source, role='command']
```
appsody
```

You should see output similar to the following:

[source, role="no_copy"]
----
The Appsody command-line tool (CLI) enables the rapid development of cloud native applications.

Complete documentation is available at https://appsody.dev

Usage:
  appsody [command]

Available Commands:
  build       Locally build a docker image of your appsody project
  completion  Generates bash tab completions
  debug       Run the local Appsody environment in debug mode
  deploy      Build and deploy your Appsody project to your Kubernetes cluster
  extract     Extract the stack and your Appsody project to a local directory
  help        Help about any command
  init        Initialize an Appsody project with a stack and template app
  list        List the Appsody stacks available to init
  operator    Install or uninstall the Appsody operator from your Kubernetes cluster.
  repo        Manage your Appsody repositories
  run         Run the local Appsody environment for your project
  stop        Stops the local Appsody docker container for your project
  test        Test your project in the local Appsody environment
  version     Show Appsody CLI version

Flags:
      --config string   config file (default is $HOME/.appsody/.appsody.yaml)
      --dryrun          Turns on dry run mode
  -h, --help            help for appsody
  -v, --verbose         Turns on debug output and logging to a file in $HOME/.appsody/logs

Use "appsody [command] --help" for more information about a command.
----

The Appsody CLI has a number of *Commands*. The majority of these
commands are for working with stacks: build, debug, run stop, test, and
extract, list.

Let’s take a look at what stacks we have available by entering:

[source, role='command']
```
appsody list
```

This command lists the available stacks and you should see something
like:

[source, role="no_copy"]
----
REPO                    ID                          VERSION     TEMPLATES   DESCRIPTION                                              
appsodyhub              java-microprofile           0.2.11      *default    Eclipse MicroProfile using OpenJ9 and Maven              
appsodyhub              java-spring-boot2           0.3.8       *default    Spring Boot using OpenJ9 and Maven                       
appsodyhub              nodejs                      0.2.5       *simple     Runtime for Node.js applications                         
appsodyhub              nodejs-express              0.2.5       *simple     Express web framework for Node.js                        
appsodyhub              nodejs-loopback             0.1.3       *scaffold   LoopBack API framework for Node.js                       
appsodyhub              swift                       0.1.4       *simple     Runtime for Swift applications
----

You’ll see that with the stacks available, we can develop new
cloud-native applications using Java, Node.js or Swift, with a number of
different, popular frameworks.

You can also register new repositories containing stacks created from
the ground up or as forks of the default stacks shipped with Appsody

To illustrate that point, we can register the repository for 
Kabanero collections, using the following command:

[source, role='command']
```
appsody repo add kabanero https://github.com/kabanero-io/collections/releases/download/v0.2.0-beta1/kabanero-index.yaml

appsody repo list
```

You should see an output similar to this:

[source, role="no_copy"]
----
NAME       	URL                                                                                          
*appsodyhub	https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml              
kabanero   	https://github.com/kabanero-io/collections/releases/download/v0.2.0-beta1/kabanero-index.yaml
----

`+Appsodyhub+` is the location where the appsody project releases its
stacks. The `+*+` indicates that this is the default repository. We can
instruct appsody to set the new kabanero repository as the default repository:

....
$ appsody repo set-default kabanero
Your default repository is now set to kabanero

$ appsody repo list

NAME      	URL                                                                                          
*kabanero 	https://github.com/kabanero-io/collections/releases/download/v0.2.0-beta1/kabanero-index.yaml
appsodyhub	https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml       
....




=== Creating a new Project with Appsody

Make a directory to contain your project:

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
mkdir -p ~/workspace/kabanero-workshop/nodejs
cd ~/workspace/kabanero-workshop/nodejs
```
--

[.tab_content.windows_section]
--
[source, role='command']
```
mkdir %USERPROFILE%\workspace\kabanero-workshop\nodejs
cd %USERPROFILE%\workspace\kabanero-workshop\nodejs
```
--

Create the new project. This project will be using the Node.JS Express framework.

[source, role='command']
appsody init kabanero/nodejs-express


When the build completes, you should see something like:

[source, role="no_copy"]
...
[InitScript] [INFO] ------------------------------------------------------------------------
[InitScript] [INFO] BUILD SUCCESS
[InitScript] [INFO] ------------------------------------------------------------------------
[InitScript] [INFO] Total time: 0.800 s
[InitScript] [INFO] Finished at: 2019-09-02T15:52:41+01:00
[InitScript] [INFO] ------------------------------------------------------------------------
Successfully initialized Appsody project


Open up the project in VS Code.

[source, role='command']
code .

Special note for compiled languages, such as Java: To experience the incremental 
update during development you will need an IDE that automatically compiles the source files each time
they are saved. For instance, VS Code (with the Red Hat
`+Language Support for Java+`), Eclipse and IntelliJ IDEA are all known
to work.


Expand the project `+src+` and you should see a structure and code like
this:

This project template was designed with simplicity in mind, containing only
a skeleton Node.JS application and Appsody control files:

[source, role="no_copy"]
```
./test/test.js
./.gitignore
./package-lock.json
./package.json
./.appsody-config.yaml
./.vscode/launch.json
./.vscode/tasks.json
./app.js
```


=== Live coding with Appsody

Let’s start the new application ready to make some edits. Enter the
following command:

[source, role='command']
appsody run

The run command for this stack has been set up to run the application 
with `node` and use hot code updates to reflect code changes made
to the source tree.

After a while you should see output similar to the following:

[source, role="no_copy"]
Running development environment...
Pulling docker image dev.local/nodejs-express:SNAPSHOT
Running command: docker pull dev.local/nodejs-express:SNAPSHOT
Error response from daemon: Get https://dev.local/v2/: Service Unavailable
[Warning] Docker image pull failed: exit status 1
Using local cache for image dev.local/nodejs-express:SNAPSHOT
Running docker command: docker run --rm -p 3000:3000 -p 8080:8080 -p 9229:9229 --name node-js-dev -v /Users/nastacio/workspace/kabanero-workshop/nodejs/:/project/user-app -v node-js-deps:/project/user-app/node_modules -v /Users/nastacio/.appsody/appsody-controller:/appsody/appsody-controller -t --entrypoint /appsody/appsody-controller dev.local/nodejs-express:SNAPSHOT --mode=run
[Container] Running APPSODY_PREP command: npm install --prefix user-app
added 170 packages from 578 contributors and audited 295 packages in 3.639s
[Container] found 0 vulnerabilities
[Container] 
Running command:  npm start
[Container] Running command:  npm start
[Container] Wait received error on APPSODY_RUN/DEBUG/TEST signal: interrupt
[Container] 
[Container] > nodejs-express@0.2.6 start /project
[Container] > node server.js
[Container] 
[Container] [Tue Oct  8 15:04:22 2019] com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5.0.5.201910032155 (Agent Core 4.0.5)
[Container] [Tue Oct  8 15:04:23 2019] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883
[Container] App started on PORT 3000
[Container] Running command:  npm start
[Container] [Warning] Wait Received error starting process of type APPSODY_RUN/DEBUG/TEST_ON_CHANGE while running command: npm start error received was: signal: interrupt
[Container] 
[Container] > nodejs-express@0.2.6 start /project
[Container] > node server.js
[Container] 
[Container] [Tue Oct  8 15:04:23 2019] com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5.0.5.201910032155 (Agent Core 4.0.5)
[Container] [Tue Oct  8 15:04:24 2019] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883
[Container] App started on PORT 3000


Let’s now make a code change. The Node.js Express stack can dynamically 
update the running application without needing a restart.

First, navigate to the REST application endpoint to confirm that there
are no esources available. Open the following link in your
browser:

http://localhost:3000/resource

You should see an `+Not Found+` response.

Modify the app.js source file to include the extra "/resource" REST path:

[source,nodejs]
----
const app = require('express')()

app.get('/', (req, res) => {
  res.send("Hello from Appsody!");
});

app.get('/resource', (req, res) => {
  res.send("Resource from Appsody!");
});

module.exports.app = app;
----

You should see that upon saving the file the source code change is detected 
and the application updated:

[source, role="no_copy"]
[Container] Running command:  npm start
[Container] [Warning] Wait Received error starting process of type APPSODY_RUN/DEBUG/TEST_ON_CHANGE while running command: npm start error received was: signal: interrupt
[Container] 
[Container] > nodejs-express@0.2.6 start /project
[Container] > node server.js
[Container] 
[Container] [Tue Oct  8 15:38:53 2019] com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5.0.5.201910032155 (Agent Core 4.0.5)
[Container] [Tue Oct  8 15:38:53 2019] com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883
[Container] App started on PORT 3000


Now if you browse http://localhost:3000/resource, you should see the message 
`+Resource from Appsody!+` instead of the original `+Not Found+` message 

Try changing the message in `+app.js+` saving and
refreshing the page. You’ll see it only takes a few seconds for the
change to take effect.

When you’re done, type `+Ctrl-C+` to end the appsody run.

=== Deploying to Kubernetes

You’ve finished writing your code and want to deploy to Kubernetes. The
Kabanero project integrates Tekton as a CI/CD pipeline for deploying to
Kubernetes (including Knative and Istio). This enables you to commit
your changes to a git repo and have a Tekton pipeline build and
potentially deploy the project.

A full Kabanero set-up was considered too much for this workshop, so
here we are going to make use of a nice little feature from Appsody,
`+appsody deploy+`. In the terminal in the root of your project, type:

[source, role='command']
appsody deploy

At the end of the deploy, you should see an output like this:

[source, role="no_copy"]
Built docker image dev.local/nodejs
Using applicationImage of: dev.local/nodejs
Attempting to apply resource in Kubernetes ...
Running command: kubectl apply -f app-deploy.yaml --namespace default
Deployment succeeded.
Appsody Deployment name is: nodejs
Running command: kubectl get rt nodejs -o jsonpath="{.status.url}" --namespace default
Attempting to get resource from Kubernetes ...
Running command: kubectl get route nodejs -o jsonpath={.status.ingress[0].host} --namespace default
Attempting to get resource from Kubernetes ...
Running command: kubectl get svc nodejs -o jsonpath=http://{.status.loadBalancer.ingress[0].hostname}:{.spec.ports[0].nodePort} --namespace default
Deployed project running at http://localhost:30062

The very last line tells you where the application is available. Let’s
call the resource by opening this endpoint in the browser:

http://localhost:30062/resource

You should now see the response from your JAX-RS resource.

Let’s take a look at the deployment. Enter:

[source, role='command']
kubectl get all


You should see an output similar to this:

[source, role="no_copy"]
--
NAME                                    READY   STATUS    RESTARTS   AGE
pod/appsody-operator-6bbddbd455-r65vp   1/1     Running   0          6m57s
pod/nodejs-7d84ddc98d-r7bnj             1/1     Running   0          44s


NAME                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE
service/appsody-operator   ClusterIP   10.100.219.241   <none>        8383/TCP         6m51s
service/kubernetes         ClusterIP   10.96.0.1        <none>        443/TCP          9m13s
service/nodejs             NodePort    10.110.138.128   <none>        3000:30062/TCP   44s


NAME                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/appsody-operator   1/1     1            1           6m57s
deployment.apps/nodejs             1/1     1            1           44s

NAME                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/appsody-operator-6bbddbd455   1         1         1       6m57s
replicaset.apps/nodejs-7d84ddc98d             1         1         1       44s
--

The entries with `+nodejs+` are your applications. The
`+appsody-operator+` are those used by Appsody to perform the
deployment.

It’s worth noting at this point that this deployment was achieved
without us having to write, or understand, a Dockerfile or Kubernetes
deployment yaml.

Now list the files in your project directory. You should see something
like this:

[source, role="no_copy"]
....
-rw-r--r--  1 nastacio  staff    628 Oct  8 14:05 app-deploy.yaml
-rw-r--r--  1 nastacio  staff    130 Oct  8 14:02 app.js
-rw-r--r--  1 nastacio  staff  51421 Oct  8 14:02 package-lock.json
-rw-r--r--  1 nastacio  staff    455 Oct  8 14:02 package.json
drwxr-xr-x  3 nastacio  staff     96 Oct  8 14:02 test
....

The `+app-deploy.yaml+` is generated from the stack and used to deploy
to Kubernetes. If you look inside the file, you’ll see entries for
`+liveness+` and `+readiness+` probes, metrics, and the service port.

Check out the `+liveness+` and `+readiness+` endpoints by pointing your
browser at the following URLs, remembering to replace the port numbers with
the port numbers from the output of the `appsody deploy` command:

* http://localhost:30062/live
* http://localhost:30062/ready

You should see something like:

[source,json]
----
// http://localhost:30062/ready

{
    "status":"UP",
    "checks":[]
}
----

These endpoints are provided by the stack health checks generated
by the project starter.

Finally, let’s undeploy the application by entering:

[source, role='command']
```
appsody deploy delete
```


You should see an output something like this:

[source, role="no_copy"]
----
....
Deleting deployment using deployment manifest app-deploy.yaml
Attempting to delete resource from Kubernetes...
Running command: kubectl delete -f app-deploy.yaml --namespace default
Deployment deleted
....
----

Check that everything was undeployed using:

[source, role='command']
```
kubectl get all
```

You should see output similar to this:

[source, role="no_copy"]
....
NAME                                    READY   STATUS    RESTARTS   AGE
pod/appsody-operator-6bbddbd455-r65vp   1/1     Running   0          13m


NAME                       TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE
service/appsody-operator   ClusterIP   10.100.219.241   <none>        8383/TCP   13m
service/kubernetes         ClusterIP   10.96.0.1        <none>        443/TCP    15m


NAME                               READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/appsody-operator   1/1     1            1           13m

NAME                                          DESIRED   CURRENT   READY   AGE
replicaset.apps/appsody-operator-6bbddbd455   1         1         1       13m
....

What if you decide you want to see the Container and Kubernetes
configuration that Appsody is using, or you want to take your project
elsewhere? You can do this as follows. Enter:

[source, role='command']
```
appsody extract --target-dir tmp-extract
```

You should see output similar to:

[source, role="no_copy"]
....
Extracting project from development environment
Pulling docker image dev.local/nodejs-express:SNAPSHOT
Running command: docker pull dev.local/nodejs-express:SNAPSHOT
Error response from daemon: Get https://dev.local/v2/: Service Unavailable
[Warning] Docker image pull failed: exit status 1
Using local cache for image dev.local/nodejs-express:SNAPSHOT
[Warning] The stack image does not contain APPSODY_PROJECT_DIR. Using /project
Running command: docker create --name nodejs-extract -v /Users/nastacio/workspace/kabanero-workshop/nodejs/:/project/user-app dev.local/nodejs-express:SNAPSHOT
Running command: docker cp nodejs-extract:/project /Users/nastacio/.appsody/extract/nodejs
Running command: docker rm nodejs-extract -f
Project extracted to /Users/nastacio/workspace/kabanero-workshop/nodejs/tmp-extract
....

Let’s take a look at the extracted project:

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
cd ~/workspace/kabanero-workshop/nodejs/tmp-extract
ls -al
```
--

[.tab_content.windows_section]
--
[source, role='command']
```
cd %USERPROFILE%\workspace\kabanero-workshop\nodejs\tmp-extract
dir
```
--

You should see output similar to the following:

[source, role="no_copy"]
....
drwxr-xr-x   10 nastacio  staff    320 Oct  3 17:55 .
drwxr-xr-x   11 nastacio  staff    352 Oct  8 14:15 ..
-rw-r--r--    1 nastacio  staff     48 Oct  3 14:41 .dockerignore
-rw-r--r--    1 nastacio  staff    878 Oct  3 14:41 Dockerfile
drwxr-xr-x  274 nastacio  staff   8768 Oct  3 17:55 node_modules
-rw-r--r--    1 nastacio  staff  92237 Oct  3 17:55 package-lock.json
-rw-r--r--    1 nastacio  staff    659 Oct  3 14:41 package.json
-rw-r--r--    1 nastacio  staff   1462 Oct  3 14:41 server.js
drwxr-xr-x    3 nastacio  staff     96 Oct  3 14:41 test
drwxr-xr-x   10 nastacio  staff    320 Oct  8 14:04 user-app
....


These are the files for the project, including those provided by the
stack. For example, the `+package.json+` has the core application definition 
for your application, and the `+Dockerfile+` is the one used to build and package
the application. The `+user-app+` is the Node.js project for your
application.

That’s it for the Appsody part of the workshop. You’ve seen how Appsody
`+stacks+` and `+templates+` make it easy to get started with a new
project with a curated and consistent dev and production environment.
You’ve also seen how Appsody makes it really easy to build
production-ready containers and deploy them to a Kubernetes environment.
Let’s now take a look at Codewind.

== Developing Cloud-native applications - Codewind

=== Using a Custom Appsody Stack from Codewind

By default, Codewind has integration for the Kabanero stacks, which are 
based on the stacks released by the Appsody project. 

It is worth looking at the Codewind configuration to understand how to
eventually include references to custom stacks, such as the one we will 
be building in this workshop.

In order to include additional stacks to the list of stacks available
inside Codewind, you can add them through the template sources panel.
Right-click the Projects icon in the Codewind section of the Visual Code
Studio Explorer and select "Manage Template Sources":

Make sure you have "Kabanero Collections" enabled and "Appsody Stacks"
disabled, otherwise you may see stacks with the same name and descriptions
in the list of stack options when creating a new Codewind project.

.Codewind template sources 
image::/img/guide/kab-workshop-codewind-template-sources.png[link="/img/guide/kab-workshop-codewind-template-sources.png" alt="Codewind template sources"]

You’re now ready to use the Kabanero collections from within Codewind.

=== Creating a new Codewind Project

We’ve seen how the Appsody CLI helps create, build and deploy projects
based on stacks and templates. Let’s now see how Codewind augments the
Appsody experience with tools for cloud-native development.

We’re going to start by creating a new Node.js project. These first
steps are the same for all the supported project types.

To get started with writing the project, hover over the *Projects* entry
underneath *Codewind* in *Visual Studio Code* and press the *+* icon to
create a new project.

.New Codewind project 
image::/img/guide/kab-workshop-new-project.png[link="/img/guide/kab-workshop-new-project.png" alt="New Codewind project"]


You should see a list of project types you can create. Select the
`+Kabanero Collections+` group, then select `Appsody Node.js Express simple template`.

.New Node.js Express project 
image::/img/guide/kab-workshop-codewind-new-nodejs.png[link="/img/guide/kab-workshop-codewind-new-nodejs.png" alt="New Node.js Express project"]

In the next field give the project a name, e.g `+kabanero-node-project+`

Press `+Enter+` to create the project.

The project has been generated and will now be building. To see the
progress, expand `+Codewind+` -> `+Projects+` and right click the menu
options `+Show all logs+`:

After a little while you should see the following log message:

[source, role="no_copy"]
....
Removing intermediate container 13648583c48c
 ---> 6f9d1a63dd11
Step 10/10 : CMD ["npm", "start"]
 ---> Running in 57255d64995d
Removing intermediate container 57255d64995d
 ---> bab327cf0931
Successfully built bab327cf0931
Successfully tagged cw-kabaneronodeproject-55db2350-ea0d-11e9-b965-597841276b82:latest
....

And the state for the project should change to `+Running+`:

.Node.js Express project running
image::/img/guide/kab-workshop-codewind-nodejs-running.png[link="/img/guide/kab-workshop-codewind-nodejs-running.png" alt="Node.js Express project running"]

The generated project contains all the boiler-plate code to get started
with developing a Node.js Express application. This is the exact same
code we saw generated for the new Appsody project.

To access the application endpoint in a browser, select the *Open App*
icon next to the project’s name, or right-click on the project and
select the `+Open App+` menu option. This opens up the application in
the running container showing a welcome page for the project.

.Launch Node.js Express application
image::/img/guide/kab-workshop-codewind-launch-nodejs.png[link="/img/guide/kab-workshop-codewind-launch-nodejs.png" alt="Launch Node.js Express application"]

Let’s take a look at the code. In the *Visual Studio Code Explorer* you should see
an entry with your Codewind project name. If you don’t find
it, right-click on the project and choose `+Add Folder to Workspace+`.
In the workspace view, expand the project and the sub-folders to show
all the files created from the Appsody template (Note, the template is
not intended to be a sample as most people would end up having to delete
the code each time, it aims to provide the starter code, server
configuration and build to which you can add your code).

The main source file is *app.js*, which serves the root path of your REST API.

Let’s modify that file to add the "/resource" REST endpoint to your application:

[source,node]
----
const app = require('express')()

app.get('/', (req, res) => {
  res.send("Hello from Appsody!");
});
 
app.get('/resource', (req, res) => {
  res.send("Resource from Appsody!");
});

module.exports.app = app;
----

Any changes you make to your code will automatically be 
re-deployed by *Codewind*, and viewed in your browser.

If you still have the logs `+OUTPUT+` tab open you will see that the
code is compiled and the application restarted. You should see messages
like:

[source, role="no_copy"]
....
[Container] > nodejs-express@0.2.6 start /project
[Container] > node server.js
[Container] 
[Container]  Wed Oct  9 01:44:20 2019  com.ibm.diagnostics.healthcenter.loader INFO: Node Application Metrics 5.0.5.201910041526 (Agent Core 4.0.5)
[Container]  Wed Oct  9 01:44:21 2019  com.ibm.diagnostics.healthcenter.mqtt INFO: Connecting to broker localhost:1883
[Container] App started on PORT 3000
....

Point your browser at the new resource (note, `+<port>+` is the port
number you saw when you first opened the application):

[source, role="no_copy"]
....
http://127.0.0.1:<port>/resource
....

You should see the following response:

[source, role="no_copy"]
....
Resource from Appsody!
....

=== Looking Inside the Container

During development you may need to look inside the container to see
what’s deployed and configured. Codwind makes this easy. Select the
`+Open Container Shell+` option:

.Open Container Shell
image::/img/guide/kab-workshop-codewind-shell.png[link="/img/guide/kab-workshop-codewind-shell.png" alt="Open Container Shell"]

The following shows the files and location where the shell opens inside
the container. This is the root of your project.

.Listing application files from container shell
image::/img/guide/kab-workshop-codewind-shell-commands.png[link="/img/guide/kab-workshop-codewind-shell-commands.png" alt="Listing application files from container shell"]

You can navigate around the various directories for the application
and its dependencies.

=== Viewing Application Metrics

Let’s take a look at the application metrics built in to Codewind.
Right-click on the application and select `+Open Application Monitor+`:

This should open a page in your browser showing the metrics
dashboard with various system resource and response time data.
To make it more interesting,
hit the REST endpoint a few times to see the effects. You should end up
with a dashboard looking something like:

.Codewind Application Metrics Dashboard
image::/img/guide/kab-workshop-codewind-performance.png[link="/img/guide/kab-workshop-codewind-performance.png" alt="Codewind Application Metrics Dashboard"]

The dashboard helps you understand the runtime characteristics of your
service. Keep the dashboard open for now.

=== Running Load Tests

Let’s now take a look at the load testing support of Codewind.
Right-click on the application and select
`+Open Performance Dashboard+`:

In a browser tab you should see the Codewind performance dashboard.
Click on `+Edit load run settings+` and change the path to point to the
REST service endpoint `+/resource+` and click `+Save+` to save
the settings. Click `+Run Load Test+`, in the dialog, give the test a
name `+Test 1+` and choose `+Run+`:

.Edit load run settings
image::/img/guide/kab-workshop-codewind-edit-load-test.png[link="/img/guide/kab-workshop-codewind-edit-load-test.png" alt="Edit load run settings"]

When the tests are complete you should see results similar to the
following (you may need to click refresh in the browser). Click the
check-boxes for `+Response+`, `+Hits+`, `+CPU+` and `+Memory+`.

.Load test results
image::/img/guide/kab-workshop-codewind-performance-test.png[link="/img/guide/kab-workshop-codewind-performance-test.png" alt="Load test results"]

To see the effect of the load test on the service, take a look at the
metrics dashboard you opened earlier. You should see spikes in the
various measures.

Let’s do some development and degrade the performance of the services.
Update the `+GET+` method with the following and save the file. As
before, the application will be automatically updated:

[source,java]
----
app.get('/resource', (req, res) => {
  setTimeout(function() {
    res.send("Resource from Appsody!");
  }, 3000);  
});
----

In the performance dashboard, click `+Run Load Test+`, give the test
another name, e.g. `+Test 2+`, and click `+Run+`. When the tests
complete, you should see results similar to the following:

.Load test results after performance degradation
image::/img/guide/kab-workshop-codewind-performance-test-2.png[link="/img/guide/kab-workshop-codewind-performance-test-2.png" alt="Load test results after performance degradation"]


We can see clearly from the chart that the response time has increased.
Revisit the metrics dashboard and we can also see the response time
increase:

.Application metrics after performance degradation
image::/img/guide/kab-workshop-codewind-performance-2.png[link="/img/guide/kab-workshop-codewind-performance-2.png" alt="Application metrics after performance degradation"]

=== Deploy the Project to Knative or Kubernetes via the CLI

The project you created is a normal Appsody project and so can be worked
with using the Appsody CLI. As per the Appsody part of this workshop,
deploy the application to Kubernetes using:

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
....
cd ~/codewind-workspace/kabanero-node-project
appsody deploy
....
--

[.tab_content.windows_section]
--
[source, role='command']
....
cd c:\codewind-workspace\kabanero-node-project
appsody deploy
....
--

If this was successful, the output of this command should be:

[source, role="no_copy"]
....
Deployed project running at http://localhost:<port>
....

Test the endpoint by opening:

[source, role="no_copy"]
....
http://127.0.0.1:<port>/resource
....

You should see the following response:

[source, role="no_copy"]
....
Resource from Appsody!
....

Congratulations! Your application is now accessible through Knative/Kubernetes.

You can undeploy the application using:

[source, role='command']
....
appsody deploy delete
....

== Working with Kabanero Collections

A collection includes everything you need to create a microservice in a
single container image, along with an enterprise-grade deployment &
integrated continuous delivery choice. Collections are developed by
application architects to match their organizational and product
requirements and work as the basis for applications created by
application developers.

A collection is defined by a combination of a stack (container images
and application templates), build/CD conventions, and deployment
best-practices.

The workshop will cover various aspects of the customization of an
existing collection, which will better prepare you for eventually
creating an entirely new collection after the workshop. 

Kabanero Collections are custom Appsody Stacks and follow the same
development process described in the
https://appsody.dev/docs/stacks/create["Creating a Stack"] section of
the Appsody website, which will be referenced throughout this section. 


=== Stacks

A https://appsody.dev/docs/stacks/stacks-overview[stack] contains at
least one pre-built container image, with the resulting runtime being
tailored to the target runtime. An application architect may to specify
different tunning parameters for a single image, such as dynamic code
reloading for development environments, or provide distinct images for
different purposes, such as an image stripped out of shell support for
production environments.

You can study the internal file structure of a stack in more detail
https://appsody.dev/docs/stacks/stack-structure[here].

=== Workshop custom stack

We are going to use a custom stack created for this workshop. Anybody can
write a stack or customize a stack for use by others. Maybe you want to
add support for another language or framework, or perhaps your company
has additional governance requirements that you want to add into an
existing stack. We’ll go into more details on stack development later,
but for now, let’s add in the stack we’ll use in this part of the
workshop.

The preparation steps for the workshop cloned the Kabanero collections
repository to your local workstation (see snippet of cloning steps below), 
so we can make local modifications and 
use `appsody stack` commands to build the custom versions of collections.

[source, role="no_copy"]
....
workshop_dir=$(echo ~)"/workspace/kabanero-workshop"

[ ! -e "${workshop_dir}/collections" ] && \
( mkdir -p "${workshop_dir}"
  cd "${workshop_dir}"
  git clone https://github.com/kabanero-io/collections )
....


The https://github.com/kabanero-io/collections[Kabanero Collections repository] has the 
complete instructions for releasing the custom collections for usage within a larger 
organization.

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
workshop_dir=$(echo ~)"/workspace/kabanero-workshop"
cd ${workshop_dir}/collections/incubator
```
--

[.tab_content.windows_section]
--
[source, role='command']
```
set workshop_dir="%USERPROFILE%\workspace\kabanero-workshop"
cd %workshop_dir%\collections\incubator
```
--

If you list the contents of that directory, you should see something like this:

[source, role="no_copy"]
----
common
java-microprofile
java-spring-boot2
nodejs
nodejs-express
nodejs-loopback
----

This is the list of Kabanero collections, which each directory containing the folder
structure matching the https://appsody.dev/docs/stacks/stack-structure[structure of an Appsody stack].
The stack we want to use is in the `+nodejs-express+` directory.

Let's take a look at the files inside that directory:

[source, role="no_copy"]
....
find . -type f
./stack.yaml
./pipelines/.gitkeep
./image/Dockerfile-stack
./image/LICENSE
./image/config/app-deploy.yaml
./image/project/test/test.js
./image/project/server.js
./image/project/Dockerfile
./image/project/.dockerignore
./image/project/package.json
./image/.dockerignore
./README.md
./templates/skaffold/test/test.js
./templates/skaffold/.gitignore
./templates/skaffold/package-lock.json
./templates/skaffold/package.json
./templates/skaffold/.vscode/launch.json
./templates/skaffold/.vscode/tasks.json
./templates/skaffold/views/index.pug
./templates/skaffold/routes/index.js
./templates/skaffold/app.js
./templates/simple/test/test.js
./templates/simple/.gitignore
./templates/simple/package-lock.json
./templates/simple/package.json
./templates/simple/.vscode/launch.json
./templates/simple/.vscode/tasks.json
./templates/simple/app.js
./collection.yaml
....

The "image" directory defines the base runtime for all templates in the collection,
with the templates for the collection listed as sub-directories of the "templates" directory.

We will be working with the "simple" template.

=== Building the custom stack

The commands for developing custom stacks are bundled under the `appsody stack` command:

[source, role='command']
```
appsody stack --help
```

[source, role="no_copy"]
....
Tools to help create and test Appsody stacks

Usage:
  appsody stack [command]

Available Commands:
  lint        Lint your stack to verify that it conforms to the standard of an Appsody stack
  package     Package a stack in the local Appsody environment
  validate    Run validation tests of a stack in the local Appsody environment
....

We want to use the `package` sub-command to generate a local copy of the stack:

[source, role='command']
```
cd nodejs-express
appsody stack package
```


You will notice the presence of the new dev-local repository:

[source, role='command']
```
appsody repo list
```

You should see:

[source, role="no_copy"]
----
NAME       	URL                                                                                          
*appsodyhub	https://github.com/appsody/stacks/releases/latest/download/incubator-index.yaml              
dev-local  	file:///Users/nastacio/.appsody/stacks/dev.local/index-dev-local.yaml                        
kabanero   	https://github.com/kabanero-io/collections/releases/download/v0.2.0-beta1/kabanero-index.yaml
----

Let’s see what stacks we now have available:

[source, role='command']
```
appsody list
```

You should now see an entry for a stack called
`+nodejs-express+` from the `+dev-local+` repository.

[source, role="no_copy"]
--
REPO       	ID               	VERSION  	TEMPLATES        	DESCRIPTION                                              
*appsodyhub	java-microprofile	0.2.17   	*default         	Eclipse MicroProfile on Open Liberty & OpenJ9 using Maven
*appsodyhub	java-spring-boot2	0.3.14   	*default, kotlin 	Spring Boot using OpenJ9 and Maven                       
*appsodyhub	nodejs           	0.2.5    	*simple          	Runtime for Node.js applications                         
*appsodyhub	nodejs-express   	0.2.7    	scaffold, *simple	Express web framework for Node.js                        
*appsodyhub	nodejs-loopback  	0.1.5    	*scaffold        	LoopBack 4 API Framework for Node.js                     
*appsodyhub	python-flask     	0.1.4    	*simple          	Flask web Framework for Python                           
*appsodyhub	swift            	0.1.4    	*simple          	Runtime for Swift applications                           
dev-local  	nodejs-express   	0.2.6    	*simple, skaffold	Express web framework for Node.js                        
kabanero   	java-microprofile	0.2.14   	*default         	Eclipse MicroProfile on Open Liberty & OpenJ9 using Maven
kabanero   	java-spring-boot2	0.3.13   	*default, kotlin 	Spring Boot using OpenJ9 and Maven                       
kabanero   	nodejs           	0.2.5    	*simple          	Runtime for Node.js applications                         
kabanero   	nodejs-express   	0.2.6    	*simple, skaffold	Express web framework for Node.js                        
kabanero   	nodejs-loopback  	0.1.4    	*scaffold        	LoopBack 4 API Framework for Node.js
--

We are now ready to start customizing this local stack and creating sample applications 
to test its functionality.


=== Collection Scenario 1: Update the release of Node.js express in the stack

In this scenario, a new version of Node.js `express` is released and you, as the application
architect, want all applications based on this stack to be migrated to
the latest release in the next development and deployment cycle.

The first step is to clone the stack, which was already executed by the
prerequisite preparation steps.


In this stack, the file `./image/project/package.json` specifies the version 
of `express`.

You now modify that version "~4.16.0" to work with the newer minor version "~4.17.0":

[source,json]
----
{
  "name": "nodejs-express",
  "version": "0.2.6",
  "description": "Node.js Express Stack",
  "license": "Apache-2.0",
  "repository": {
    "type": "git",
    "url": "https://github.com/appsody/stacks.git",
    "directory": "incubator/nodejs-express/image/project"
  },
  "scripts": {
    "debug": "node --inspect=0.0.0.0 server.js",
    "start": "node server.js",
    "test": "mocha"
  },
  "dependencies": {
    "@cloudnative/health-connect": "^2.0.0",
    "appmetrics-prometheus": "^3.0.0",
    "express": "~4.17.0"   // <1>
  },
  "devDependencies": {
    "chai": "^4.2.0",
    "mocha": "~6.1.0",
    "request": "^2.88.0",
    "appmetrics-dash": "^5.0.0"
  }
}
----
<1> Newer `express` framework version

With the version changed, we need to rebuild the stack before proceeding
with the stack validation steps.

[source, role='command']
....
appsody stack package
....

As an optimization step, since all Docker images being generated for this local
stack are not located in a remote repository, we can save time by informing
Appsody to not download images that are already in the local repository:

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
export APPSODY_PULL_POLICY=IFNOTPRESENT
```
--

[.tab_content.windows_section]
--
[source, role='command']
```
set APPSODY_PULL_POLICY=IFNOTPRESENT
```
--

It is now time to verify the changes from the perspective of the
application developer. We can go back to the original application
directory and trigger another run, which will use the updated stack:

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
workshop_dir=$(echo ~)"/workspace/kabanero-workshop"
mkdir -p "${workshop_dir}/nodejs-local"
cd "${workshop_dir}/nodejs-local"

appsody init dev-local/nodejs-express
appsody run
```
--

[.tab_content.windows_section]
--
[source, role='command']
```
set workshop_dir="%USERPROFILE%\workspace\kabanero-workshop"
mkdir "%workshop_dir%\nodejs-local"
cd "%workshop_dir%\nodejs-local"

appsody init dev-local/nodejs-express
appsody run
```
--

Once the application is running, we can open a different terminal window and use 
a `docker exec` command to inspect the content of the package.json for the application 
and verify that the `express` framework version now reflects the new value placed in 
the stack:

[source, role='command']
```
docker exec -it nodejs-local-dev /bin/sh -c "cat package.json"
```

[source, role="no_copy"]
....
{
  ...
  "dependencies": {
    "@cloudnative/health-connect": "^2.0.0",
    "appmetrics-prometheus": "^3.0.0",
    "express": "~4.17.0"    <<<<<<< new express version in the stack
  }
  ...
}
....

End the application with `+Ctrl+C+`.

=== Collection Scenario 2: Custom application template

A stack contains at least one application template, which is the set of
application files placed in the application directory during the initial
creation of a project. The default template for a stack is defined in
stack.yaml file in the stack directory and  used by
`+appsody init+` when the user does not specify a template name.

For instance, for the nodejs-express stack, we can see the following content
for stack.yaml:

[source, role="no_copy"]
....
name: Node.js Express
version: 0.2.6
description: Express web framework for Node.js
license: Apache-2.0
language: nodejs
...
default-template: simple  <<<<<
....


An application architect can create new templates to reflect different
starting points for application developers, such as a default template
for a simple stateless application or a more complex template with
starter code for connecting to a remote database.

In this scenario, we will inspect an alternative template with a
PostgreSQL database connection endpoint, then create and test an
application starter using that template.

We first need to create the alternative template, which will be based
on the "simple" template:

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
workshop_dir=$(echo ~)"/workspace/kabanero-workshop"
cd "${workshop_dir}/collections/incubator/nodejs-express/templates"
cp -rf simple psqldb

```
--

[.tab_content.windows_section]
--
[source, role='command']
```
set workshop_dir="%USERPROFILE%\workspace\kabanero-workshop"
cd "%workshop_dir%\collections\incubator\nodejs-express/templates"
copy /s simple psqldb
```
--

The next step is to modify the "package.json" file for the template 
to include the PostgreSQL dependency, which is in the new "psqldb" directory
created in the previous step:


[source, role='command']
```
cd psqldb
```

Insert the new line for "pg-promise" in the package.json file, 
inside the "devDependencies" block, as follows:

[source, role="no_copy"]
.package.json
[source, json, linenums, role='code_column hide_tags=copyright,fallback,fallbackMethod']
----
include::collections/incubator/nodejs-express/templates/psqldb/package.json[]
----

The next step is to show how the template code could have a small sample
of database connectivity. Notice we are hardcoding the database connectivity
parameters in the interest of simplicity, but in a real application these
values should be provided through an external mechanism, such as Docker 
environment variables (`appsody run --docker-options="-e ..."`) or, later
in production, through secrets bound to the Kubernetes deployment or pod.

Modify the `app.js` code inside the newly created "psqldb" directory to 
look like the content below:

app.js
[source, javascript, role='code_column hide_tags=copyright,fallback,fallbackMethod']
----
include::collections/incubator/nodejs-express/templates/psqldb/app.js[]
----

We are now ready to re-build our collection to include the new template:

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
workshop_dir=$(echo ~)"/workspace/kabanero-workshop"
cd "${workshop_dir}/collections/incubator/nodejs-express"

appsody stack package
```
--

[.tab_content.windows_section]
--
[source, role='command']
```
set workshop_dir="%USERPROFILE%\workspace\kabanero-workshop"
cd "%workshop_dir%\collections\incubator\nodejs-express"

appsody stack package
```
--

We can now see the new template next to the other templates in the nodejs-express
stack:

[source, role='command']
```
appsody list dev-local
```

Which should show the following output, where you notice the new "psqldb" template
in the "TEMPLATES" column:

[source, role="no_copy"]
....
REPO     	ID            	VERSION  	TEMPLATES                	DESCRIPTION                      
dev-local	nodejs-express	0.2.6    	psqldb, *simple, skaffold	Express web framework for Node.js
....

Before testing our application, our next step is to instantiate a local PostgreSQL database. We will use a custom docker network for both the PostgreSQL database container and the application container, which makes it easier for the application container to locate the database container by hostname instead of IP address.

[source, role='command']
```
docker network create workshop_nw

docker run --rm -it --name workshop-postgres --hostname psqldb --network workshop_nw -e POSTGRES_PASSWORD=mysecretpassword -d postgres 
```

Ensure the database container is running:

[source, role='command']
```
docker ps

b66c53a3be0f        postgres                                                  "docker-entrypoint.s…"   22 seconds ago      Up 21 seconds       5432/tcp                    workshop-postgres
```

Now we can create a new application, using the template containing the
database resource:


[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
workshop_dir=$(echo ~)"/workspace/kabanero-workshop"
mkdir -p "${workshop_dir}/nodejs-db"
cd "${workshop_dir}/nodejs-db"
```
--

[.tab_content.windows_section]
--
[source, role='command']
```
set workshop_dir="%USERPROFILE%\workspace\kabanero-workshop"
mkdir "%workshop_dir%\nodejs-db"
cd "%workshop_dir%\nodejs-db"
```
--


All users:

....
appsody init dev-local/nodejs-express psqldb

appsody run --network workshop_nw
....

Wait for the application to complete its startup cycle and verify that
the new endpoint is available, by opening the
http://localhost:3000/database/ URL in a web browser, where you
should shee output like this:

....
PostgreSQL 12.0 (Debian 12.0-1.pgdg100+1) on x86_64-pc-linux-gnu, compiled by gcc (Debian 8.3.0-6) 8.3.0, 64-bit
....

End the application with `+Ctrl+C+`, stop the workshop-postgres
container, and delete the custom network:

[source, role='command']
```
docker stop workshop-postgres
docker network rm workshop_nw
```

=== Build/CD

A collection also specifies how applications should be built and
packaged, encoding conventions about compilation aspects, packaging
tooling, unit test enforcement, static code analysis, and many others. A
full Kabanero toolchain is implemented as a sequence of steps that
happen both inside and outside the container boundaries, and this
workshop covers the steps that happen within the container boundaries,
such as compilation and packaging of binaries.

This portion of the instructions is executed directly when the developer
invokes `+appsody build+` or implicitly, when the developer invokes
`+appsody deploy+` and there are outstanding code changes since the last
build.

=== Collection Scenario 3: Add static code verification to build process

In this scenario, the entire team discussed ways of making code reviews
more efficient and agreed on ensuring minimal coding guidelines for all
applications based on that stack.

After considering multiple tools, the team agreed on using
https://maven.apache.org/plugins/maven-checkstyle-plugin/usage.html[eslint]
, and the application architect can make that modification to the stack
image itself.

For simplicity we will use the default eslint rules, so that we need to
add an appropriate eslint configuration file in the image and invoke 
`eslint` in the application code.

Locate the Dockerfile for the stack:

....
${workshop_dir}/collections/incubator/nodejs-express/image/project/Dockerfile
....

And introduce the following lines right before the line containing
`WORKDIR /project`

[source, role="no_copy"]
----
RUN chown -hR node:node /project

# ESLint invocation
RUN npm install eslint \
    && echo 'module.exports = { \
    "env": { \
        "browser": false, \
        "commonjs": true, \
        "es6": true \
    }, \
    "extends": "eslint:recommended", \
    "globals": { \
        "Atomics": "readonly", \
        "SharedArrayBuffer": "readonly" \
    }, \
    "parserOptions": { \
        "ecmaVersion": 2018 \
    }, \
    "rules": { \
      "no-empty": "warn" \
    } \
};' > .eslintrc.js \
    && echo 'test/*' >  .eslintignore \
    && ./node_modules/.bin/eslint /project/user-app

WORKDIR /project
----

With the change in place, we can rebuild the stack again.


[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
workshop_dir=$(echo ~)"/workspace/kabanero-workshop"
cd "${workshop_dir}/collections/incubator/nodejs-express"

appsody stack package 
```
--

[.tab_content.windows_section]
--
[source, role='command']
```
set workshop_dir="%USERPROFILE%\workspace\kabanero-workshop"
cd "%workshop_dir%\collections\incubator\nodejs-express"

appsody stack package 
```
--

With the code verification in place, we are almost ready to see the new code 
verification step in action when an application developer executes `+appsody build+`:

First we create a source file inside the `nodejs-local` project, with a violation 
to the default rule against empty blocks, named app-rule-violation.js

[source, js]
```
var a=1
if (a) {
}
```

[.tab_link.mac_link]
`*MAC*`

[.tab_link.windows_link]
`*WINDOWS*`

[.tab_content.mac_section]
--
[source, role='command']
```
workshop_dir=$(echo ~)"/workspace/kabanero-workshop"
cd "${workshop_dir}/nodejs-local"

appsody build
```
--

[.tab_content.windows_section]
--
[source, role='command']
```
set workshop_dir="%USERPROFILE%\workspace\kabanero-workshop"
cd "%workshop_dir%\nodejs-local"

appsody build
```

Eventually you will see the following log snipped pass by, indicating
the new checks during build time: 

--

[source, role="no_copy"]
----
...
[Docker]  ---> Running in 0b8bf6444ceb
[Docker] + eslint@6.6.0
[Docker] added 126 packages from 560 contributors, updated 1 package and audited 474 packages in 6.615s
[Docker] found 0 vulnerabilities
[Docker] 
[Docker] 
[Docker] /project/user-app/app-rule-violation.js
[Docker]   2:8  warning  Empty block statement  no-empty
[Docker] 
[Docker] ✖ 1 problem (0 errors, 1 warning)
[Docker] 
...
----


=== Collection Scenario 4: Stack versioning

Appsody supports https://semver.org/[semantic versioning] during
development of stacks and applications. Notice how the check from the previous 
scenario does not fail the build process, but instead prints a summary of warnings 
for the developer.

This decision was done by design, as an application architect may want
to give some time for the whole team to address the issues raised by the 
static code analysis without suddenly disrupting their workflow.

In this scenario, we want to show how the application architect could
release a new version of the stack that will treat the warnings as blocking
errors, but will not automatically get picked up by developers immediately 
after release, so we need to understand how Appsody tags stack images.

The initial version of the stack used in this workshop is 0.2.*, which
is listed in the output of `+appsody list+`. 

[source, role="no_copy"]
--
appsody list dev-local 

REPO     	ID            	VERSION  	TEMPLATES                	DESCRIPTION                                         
dev-local	nodejs-express	0.2.7    	psqldb, scaffold, *simple	Express web framework for Node.js          
--

Locate the stack metadata file for the stack;

....
${workshop_dir}/collections/incubator/nodejs-express/stack.yaml
....


Now modify the version of the stack in "stack.yaml" to replace the "version" field
with 0.3.0, so that the final file looks like this:

[source]
----
name: Node.js Express
version: 0.3.0
description: Express web framework for Node.js
...
default-template: simple
----

Locate the Dockerfile for the stack:

....
${workshop_dir}/collections/incubator/nodejs-express/image/project/Dockerfile
....

Modify the line with the definition for the rule "no-empty" to 
be treated as an error:

[source, role="no_copy"]
----
...
    "rules": { \
      "no-empty": "error" \
    } \
...
----

Before packaging the modified image, let's tag the original image
with the minor version of the stack before the modifications:

[source, role='command']
```
docker tag dev.local/nodejs-express:SNAPSHOT dev.local/nodejs-express:0.2
```

Note that this extra step of tagging an image with a version while
making changes to stacks will no longer be required once Appsody
https://github.com/appsody/appsody/issues/526[GitHub issue #526]
is addressed.

We can now proceed to package and tag the modified stack:

[source, role='command']
```
appsody stack package
docker tag dev.local/nodejs-express:SNAPSHOT dev.local/nodejs-express:0.3
```


With the the new stack updated and packaged, we can turn back to the
application and modify

Locate the directory for the application being used to test the stack;
....
${workshop_dir}/nodejs-local
....

Modify the file named `.appsody-config.yaml` to use the new stack
version. The final file contents should look like this:

[source, role="no_copy"]
----
project-name: nodejs-local
stack: dev.local/nodejs-express:0.3
----

We can now build the application using the updated stack and observe the
new behavior, where the rule violation causes the build to break.

[source, role="no_copy"]
----
[Docker] + eslint@6.6.0
[Docker] added 126 packages from 560 contributors, updated 1 package and audited 474 packages in 6.33s
[Docker] found 0 vulnerabilities
[Docker] 
[Docker] 
[Docker] /project/user-app/app-rule-violation.js
[Docker]   2:8  error  Empty block statement  no-empty
[Docker] 
[Docker] ✖ 1 problem (1 error, 0 warnings)
[Docker] 
[Docker] The command '/bin/sh -c npm install eslint     && echo 'module.exports = {     "env": {         "browser": false,         "commonjs": true,         "es6": true     },     "extends": "eslint:recommended",     "globals": {         "Atomics": "readonly",         "SharedArrayBuffer": "readonly"     },     "parserOptions": {         "ecmaVersion": 2018     },     "rules": {       "no-empty": "error"     } };' > .eslintrc.js     && echo 'test/*' >  .eslintignore     && ./node_modules/.bin/eslint /project/user-app' returned a non-zero code: 1
[Error] exit status 1
----

At this point, developers still using the previous version would be notified 
to ensure all errors are fixed before updating the `.appsody-config.yaml` 
for their application, probably receiving some grace period until the previous 
stack is discontinued.


== Further reading: Development versus production behaviour

The previous scenarios showed relatively simple changes, but Kabanero collections
can accommodate more sophisticated behaviours, where the container image
is setup with additional debugging capabilitites during development and
stripped out of those capabilities during production.

You can read more about deciding on whether to create new stacks or
modify existing stacks in https://developer.ibm.com/articles/customizing-appsody/[this article].
If you decide to create a new stack, https://developer.ibm.com/tutorials/create-appsody-stack/[this tutorial] 
has excellent guidance for that activity.

This
https://github.com/appsody/stacks/pull/56[Git pull request] shows how
that type of different behaviour can be achieved, by exploring the usage
of https://appsody.dev/docs/stacks/stack-structure[different modes of a
stack]: "initialization", "rapid local development", and "build and
deploy".
